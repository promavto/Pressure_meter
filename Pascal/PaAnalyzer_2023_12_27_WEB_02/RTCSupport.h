#pragma once
//--------------------------------------------------------------------------------------------------------------------------------------

#include <Arduino.h>
#include <Wire.h>
#include "AbstractModule.h"

#define DS3231_ADDRESS        0x68   // I2C address for DS3231
#define DS3231_TIME           0x00   // Time register
#define DS3231_ALARM1         0x07   // Alarm 1 register
#define DS3231_ALARM2         0x0B   // Alarm 2 register
#define DS3231_CONTROL        0x0E   // Control register
#define DS3231_STATUSREG      0x0F   // Status register
#define DS3231_TEMPERATUREREG 0x11   // Temperature register (high byte - low byte is at 0x12), 10-bit
///< temperature value

/** Constants */
#define SECONDS_PER_DAY 86400L       // 60 * 60 * 24
#define SECONDS_FROM_1970_TO_2000 946684800 // Unixtime for 2000-01-01 00:00:00, useful for initialization

class TimeSpan;

//--------------------------------------------------------------------------------------------------------------------------------------
struct RTCTime // данные по текущему времени
{
	uint8_t second; // секунда (0-59)
	uint8_t minute; // минута (0-59)
	uint8_t hour; // час (0-23)
	uint8_t dayOfWeek; // день недели (1 - понедельник и т.д.)
	uint8_t dayOfMonth; // день месяца (1-31)
	uint8_t month; // месяц(1-12)
	uint16_t year; // формат - ХХХХ

	uint32_t unixtime() const;
	RTCTime maketime(uint32_t unixtime);


};
//--------------------------------------------------------------------------------------------------------------------------------------



class DateTime 
{
public:
	DateTime(uint32_t t = SECONDS_FROM_1970_TO_2000);
	DateTime(uint16_t year, uint8_t month, uint8_t day, uint8_t hour = 0, uint8_t min = 0, uint8_t sec = 0);
	DateTime(const DateTime &copy);
	DateTime(const char *date, const char *time);
	DateTime(const __FlashStringHelper *date, const __FlashStringHelper *time);
	DateTime(const char *iso8601date);
	bool isValid() const;
	char *toString(char *buffer);

	/*!
		@brief  Return the year.
		@return Year (range: 2000--2099).
	*/
	uint16_t year() const { return 2000U + yOff; }
	/*!
		@brief  Return the month.
		@return Month number (1--12).
	*/
	uint8_t month() const { return m; }
	/*!
		@brief  Return the day of the month.
		@return Day of the month (1--31).
	*/
	uint8_t day() const { return d; }
	/*!
		@brief  Return the hour
		@return Hour (0--23).
	*/
	uint8_t hour() const { return hh; }

	uint8_t twelveHour() const;
	/*!
		@brief  Return whether the time is PM.
		@return 0 if the time is AM, 1 if it's PM.
	*/
	uint8_t isPM() const { return hh >= 12; }
	/*!
		@brief  Return the minute.
		@return Minute (0--59).
	*/
	uint8_t minute() const { return mm; }
	/*!
		@brief  Return the second.
		@return Second (0--59).
	*/
	uint8_t second() const { return ss; }

	
	uint8_t dayOfWeek() const;
	//uint8_t dayOfTheWeek() const;

	/* 32-bit times as seconds since 2000-01-01. */
	uint32_t secondstime() const;

	/* 32-bit times as seconds since 1970-01-01. */
	uint32_t unixtime(void) const;

	/*!
		Format of the ISO 8601 timestamp generated by `timestamp()`. Each
		option corresponds to a `toString()` format as follows:
	*/
	enum timestampOpt {
		TIMESTAMP_FULL, //!< `YYYY-MM-DDThh:mm:ss`
		TIMESTAMP_TIME, //!< `hh:mm:ss`
		TIMESTAMP_DATE  //!< `YYYY-MM-DD`
	};
	String timestamp(timestampOpt opt = TIMESTAMP_FULL);

	DateTime operator+(const TimeSpan &span);
	DateTime operator-(const TimeSpan &span);
	TimeSpan operator-(const DateTime &right);
	bool operator<(const DateTime &right) const;

	/*!
		@brief  Test if one DateTime is greater (later) than another.
		@warning if one or both DateTime objects are invalid, returned value is
		  meaningless
		@see use `isValid()` method to check if DateTime object is valid
		@param right DateTime object to compare
		@return True if the left DateTime is later than the right one,
		  false otherwise
	*/
	bool operator>(const DateTime &right) const { return right < *this; }

	/*!
		@brief  Test if one DateTime is less (earlier) than or equal to another
		@warning if one or both DateTime objects are invalid, returned value is
		  meaningless
		@see use `isValid()` method to check if DateTime object is valid
		@param right DateTime object to compare
		@return True if the left DateTime is earlier than or equal to the
		  right one, false otherwise
	*/
	bool operator<=(const DateTime &right) const { return !(*this > right); }

	/*!
		@brief  Test if one DateTime is greater (later) than or equal to another
		@warning if one or both DateTime objects are invalid, returned value is
		  meaningless
		@see use `isValid()` method to check if DateTime object is valid
		@param right DateTime object to compare
		@return True if the left DateTime is later than or equal to the right
		  one, false otherwise
	*/
	bool operator>=(const DateTime &right) const { return !(*this < right); }
	bool operator==(const DateTime &right) const;

	/*!
		@brief  Test if two DateTime objects are not equal.
		@warning if one or both DateTime objects are invalid, returned value is
		  meaningless
		@see use `isValid()` method to check if DateTime object is valid
		@param right DateTime object to compare
		@return True if the two objects are not equal, false if they are
	*/
	bool operator!=(const DateTime &right) const { return !(*this == right); }

protected:
	uint8_t yOff; ///< Year offset from 2000
	uint8_t m;    ///< Month 1-12
	uint8_t d;    ///< Day 1-31
	uint8_t hh;   ///< Hours 0-23
	uint8_t mm;   ///< Minutes 0-59
	uint8_t ss;   ///< Seconds 0-59
};

/**************************************************************************/
class TimeSpan 
{
public:
	TimeSpan(int32_t seconds = 0);
	TimeSpan(int16_t days, int8_t hours, int8_t minutes, int8_t seconds);
	TimeSpan(const TimeSpan &copy);

	/*!
		@brief  Number of days in the TimeSpan краткое количество дней во временном интервале
				e.g. 4
		@return int16_t days
	*/
	int16_t days() const { return _seconds / 86400L; }
	/*!
		@brief  Number of hours in the TimeSpan
				This is not the total hours, it includes the days
				e.g. 4 days, 3 hours - NOT 99 hours
		@return int8_t hours
	*/
	int8_t hours() const { return _seconds / 3600 % 24; }
	/*!
		@brief  Number of minutes in the TimeSpan
				This is not the total minutes, it includes days/hours
				e.g. 4 days, 3 hours, 27 minutes
		@return int8_t minutes
	*/
	int8_t minutes() const { return _seconds / 60 % 60; }
	/*!
		@brief  Number of seconds in the TimeSpan
				This is not the total seconds, it includes the days/hours/minutes
				e.g. 4 days, 3 hours, 27 minutes, 7 seconds
		@return int8_t seconds
	*/
	int8_t seconds() const { return _seconds % 60; }
	/*!
		@brief  Total number of seconds in the TimeSpan, e.g. 358027
		@return int32_t seconds
	*/
	int32_t totalseconds() const { return _seconds; }

	TimeSpan operator+(const TimeSpan &right);
	TimeSpan operator-(const TimeSpan &right);

protected:
	int32_t _seconds; ///< Actual TimeSpan value is stored as seconds
};

/** DS3231 SQW pin mode settings */
enum Ds3231SqwPinMode 
{
	DS3231_OFF            = 0x1C,            /**< Off */
	DS3231_SquareWave1Hz  = 0x00,  /**<  1Hz square wave */
	DS3231_SquareWave1kHz = 0x08,  /**<  1kHz square wave */
	DS3231_SquareWave4kHz = 0x10,  /**<  4kHz square wave */
	DS3231_SquareWave8kHz = 0x18   /**<  8kHz square wave */
};

/** DS3231 Alarm modes for alarm 1 */
enum Ds3231Alarm1Mode {
	DS3231_A1_PerSecond = 0x0F,   /**< Alarm once per second */
	DS3231_A1_Second    = 0x0E,   /**< Alarm when seconds match */
	DS3231_A1_Minute    = 0x0C,   /**< Alarm when minutes and seconds match */
	DS3231_A1_Hour      = 0x08,   /**< Alarm when hours, minutes and seconds match */
	DS3231_A1_Date      = 0x00,   /**< Alarm when date (day of month), hours, minutes and seconds match */
	DS3231_A1_Day       = 0x10    /**< Alarm when day (day of week), hours, minutes and seconds match */
};
/** DS3231 Alarm modes for alarm 2 */
enum Ds3231Alarm2Mode 
{
	DS3231_A2_PerMinute = 0x7,   /**< Alarm once per minute	(whenever seconds are 0) */
	DS3231_A2_Minute    = 0x6,   /**< Alarm when minutes match */
	DS3231_A2_Hour      = 0x4,   /**< Alarm when hours and minutes match */
	DS3231_A2_Date      = 0x0,   /**< Alarm when date (day of month), hours	and minutes match */
	DS3231_A2_Day       = 0x8    /**< Alarm when day (day of week), hours and minutes match */
};

/**************************************************************************/
/*!
	@brief  RTC based on the DS3231 chip connected via I2C and the Wire library
*/
/**************************************************************************/
class RTC_DS3231 
{
public:
	boolean begin(TwoWire *wireInstance = &Wire);
	void adjust(const DateTime &dt);
	bool lostPower(void);
	DateTime now();
	Ds3231SqwPinMode readSqwPinMode();
	void writeSqwPinMode(Ds3231SqwPinMode mode);
	bool setAlarm1(const DateTime &dt, Ds3231Alarm1Mode alarm_mode);
	bool setAlarm2(const DateTime &dt, Ds3231Alarm2Mode alarm_mode);
	void disableAlarm(uint8_t alarm_num);
	void clearAlarm(uint8_t alarm_num);
	bool alarmFired(uint8_t alarm_num);
	void enable32K(void);
	void disable32K(void);
	bool isEnabled32K(void);
	float getTemperature(); // in Celsius degree
	RTCTime getTime();

	// Мои добавления
	const char* getDayOfWeekStr(const RTCTime& t);
	const char* getTimeStr(const RTCTime& t);
	const char* getDateStr(const RTCTime& t);


	static char workBuff[12]; // буфер под дату/время

protected:
	TwoWire *RTCWireBus;
};

/**************************************************************************/
/*!
	@brief  RTC using the internal millis() clock, has to be initialized before
   use. NOTE: this is immune to millis() rollover events.
*/
/**************************************************************************/
class RTC_Millis 
{
	public:
		/*!
			@brief  Start the RTC
			@param dt DateTime object with the date/time to set
		*/
		static void begin(const DateTime &dt) { adjust(dt); }
		static void adjust(const DateTime &dt);
		static DateTime now();

	protected:
		static uint32_t lastUnix;   ///< Unix time from the previous call to now() -
									///< prevents rollover issues
		static uint32_t lastMillis; ///< the millis() value corresponding to the last
									///< **full second** of Unix time
};

/**************************************************************************/
/*!
	@brief  RTC using the internal micros() clock, has to be initialized before
			use. Unlike RTC_Millis, this can be tuned in order to compensate for
			the natural drift of the system clock. Note that now() has to be
			called more frequently than the micros() rollover period, which is
			approximately 71.6 minutes.
*/
/**************************************************************************/
class RTC_Micros 
{
	public:
		/*!
			@brief  Start the RTC
			@param dt DateTime object with the date/time to set
		*/
		static void begin(const DateTime &dt) { adjust(dt); }
		static void adjust(const DateTime &dt);
		static void adjustDrift(int ppm);
		static DateTime now();

	protected:
		static uint32_t microsPerSecond; ///< Number of microseconds reported by
										 ///< micros() per "true" (calibrated) second
		static uint32_t lastUnix;   ///< Unix time from the previous call to now() -
									///< prevents rollover issues
		static uint32_t lastMicros; ///< micros() value corresponding to the last full
									///< second of Unix time
};

//======================================================================================================================================
